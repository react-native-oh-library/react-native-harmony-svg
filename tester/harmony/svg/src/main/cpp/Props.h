
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <jsi/jsi.h>
#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <react/renderer/graphics/Color.h>
#include <react/renderer/imagemanager/primitives.h>
#include <vector>

namespace facebook {
namespace react {

struct RNSVGSvgViewAndroidNativeBackgroundAndroidStruct {
    std::string type;
    Float color;
    bool borderless;
    Float rippleRadius;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                RNSVGSvgViewAndroidNativeBackgroundAndroidStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_type = map.find("type");
    if (tmp_type != map.end()) {
        fromRawValue(context, tmp_type->second, result.type);
    }
    auto tmp_color = map.find("color");
    if (tmp_color != map.end()) {
        fromRawValue(context, tmp_color->second, result.color);
    }
    auto tmp_borderless = map.find("borderless");
    if (tmp_borderless != map.end()) {
        fromRawValue(context, tmp_borderless->second, result.borderless);
    }
    auto tmp_rippleRadius = map.find("rippleRadius");
    if (tmp_rippleRadius != map.end()) {
        fromRawValue(context, tmp_rippleRadius->second, result.rippleRadius);
    }
}

static inline std::string toString(const RNSVGSvgViewAndroidNativeBackgroundAndroidStruct &value) {
    return "[Object RNSVGSvgViewAndroidNativeBackgroundAndroidStruct]";
}

struct RNSVGSvgViewAndroidNativeForegroundAndroidStruct {
    std::string type;
    Float color;
    bool borderless;
    Float rippleRadius;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                RNSVGSvgViewAndroidNativeForegroundAndroidStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_type = map.find("type");
    if (tmp_type != map.end()) {
        fromRawValue(context, tmp_type->second, result.type);
    }
    auto tmp_color = map.find("color");
    if (tmp_color != map.end()) {
        fromRawValue(context, tmp_color->second, result.color);
    }
    auto tmp_borderless = map.find("borderless");
    if (tmp_borderless != map.end()) {
        fromRawValue(context, tmp_borderless->second, result.borderless);
    }
    auto tmp_rippleRadius = map.find("rippleRadius");
    if (tmp_rippleRadius != map.end()) {
        fromRawValue(context, tmp_rippleRadius->second, result.rippleRadius);
    }
}

struct RNSVGPaintStruct {
    int type;
    SharedColor payload;
    std::string brushRef;
};
static inline void fromRawValue(const PropsParserContext &context, const RawValue &value, RNSVGPaintStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_type = map.find("type");
    if (tmp_type != map.end()) {
        fromRawValue(context, tmp_type->second, result.type);
    }
    auto tmp_payload = map.find("payload");
    if (tmp_payload != map.end()) {
        fromRawValue(context, tmp_payload->second, result.payload);
    }
    auto tmp_brushRef = map.find("brushRef");
    if (tmp_brushRef != map.end()) {
        fromRawValue(context, tmp_brushRef->second, result.brushRef);
    }
}

static inline std::string toString(const RNSVGSvgViewAndroidNativeForegroundAndroidStruct &value) {
    return "[Object RNSVGSvgViewAndroidNativeForegroundAndroidStruct]";
}

struct RNSVGSvgViewAndroidHitSlopStruct {
    Float left;
    Float top;
    Float right;
    Float bottom;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                RNSVGSvgViewAndroidHitSlopStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_left = map.find("left");
    if (tmp_left != map.end()) {
        fromRawValue(context, tmp_left->second, result.left);
    }
    auto tmp_top = map.find("top");
    if (tmp_top != map.end()) {
        fromRawValue(context, tmp_top->second, result.top);
    }
    auto tmp_right = map.find("right");
    if (tmp_right != map.end()) {
        fromRawValue(context, tmp_right->second, result.right);
    }
    auto tmp_bottom = map.find("bottom");
    if (tmp_bottom != map.end()) {
        fromRawValue(context, tmp_bottom->second, result.bottom);
    }
}

static inline std::string toString(const RNSVGSvgViewAndroidHitSlopStruct &value) {
    return "[Object RNSVGSvgViewAndroidHitSlopStruct]";
}
class JSI_EXPORT RNSVGSvgViewAndroidProps final : public ViewProps {
public:
    RNSVGSvgViewAndroidProps() = default;
    RNSVGSvgViewAndroidProps(const PropsParserContext &context, const RNSVGSvgViewAndroidProps &sourceProps,
                             const RawProps &rawProps);

#pragma mark - Props

    std::string bbWidth{};
    std::string bbHeight{};
    Float minX{0.0};
    Float minY{0.0};
    Float vbWidth{0.0};
    Float vbHeight{0.0};
    std::string align{};
    int meetOrSlice{0};
    SharedColor tintColor{};
    SharedColor color{};
    // std::string pointerEvents{};
    bool hasTVPreferredFocus{false};
    Float borderTopEndRadius{0.0};
    Float borderBottomStartRadius{0.0};
    SharedColor borderBottomColor{};
    int nextFocusDown{0};
    SharedColor borderRightColor{};
    int nextFocusRight{0};
    SharedColor borderLeftColor{};
    SharedColor borderColor{};
    bool removeClippedSubviews{false};
    int nextFocusForward{0};
    int nextFocusUp{0};
    bool accessible{false};
    SharedColor borderStartColor{};
    Float borderBottomEndRadius{0.0};
    SharedColor borderEndColor{};
    bool focusable{false};
    RNSVGSvgViewAndroidNativeBackgroundAndroidStruct nativeBackgroundAndroid{};
    Float borderTopStartRadius{0.0};
    RNSVGSvgViewAndroidNativeForegroundAndroidStruct nativeForegroundAndroid{};
    std::string backfaceVisibility{};
    std::string borderStyle{};
    bool needsOffscreenAlphaCompositing{false};
    RNSVGSvgViewAndroidHitSlopStruct hitSlop{};
    SharedColor borderTopColor{};
    int nextFocusLeft{0};
    double borderTopRightRadius{0.0};
    double borderBottomRightRadius{0.0};
    double borderRadius{0.0};
    double borderBottomLeftRadius{0.0};
    double borderTopLeftRadius{0.0};
};

struct RNSVGBrushStruct {
    std::string type;
    RawValue payload;
    RawValue brushRef;
};


class RNSVGCommonProps : public ViewProps {
public:
    RNSVGCommonProps() = default;
    RNSVGCommonProps(const PropsParserContext &context, const RNSVGCommonProps &sourceProps, const RawProps &rawProps);
    std::string name{};
    Float opacity{1.0};
    std::vector<Float> matrix{};
    std::string mask{};
    std::string markerStart{};
    std::string markerMid{};
    std::string markerEnd{};
    std::string clipPath{};
    int clipRule{0};
    RNSVGPaintStruct fill{};
    Float fillOpacity{1.0};
    int fillRule{1};
    RNSVGPaintStruct stroke{};
    Float strokeOpacity{1.0};
    std::string strokeWidth{"1"};
    int strokeLinecap{0};
    int strokeLinejoin{0};
    std::vector<std::string> strokeDasharray{};
    Float strokeDashoffset{0.0};
    Float strokeMiterlimit{0.0};
    std::vector<std::string> propList{};
    std::string display{};
    int vectorEffect{0};
    bool responsible{false};
};

class JSI_EXPORT RNSVGCircleProps final : public RNSVGCommonProps {
public:
    RNSVGCircleProps() = default;
    RNSVGCircleProps(const PropsParserContext &context, const RNSVGCircleProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string cx{};
    std::string cy{};
    std::string r{};
};


struct RNSVGClipPathFontStruct {
    std::string fontStyle;
    std::string fontVariant;
    std::string fontWeight;
    std::string fontStretch;
    std::string fontSize;
    std::string fontFamily;
    std::string textAnchor;
    std::string textDecoration;
    std::string letterSpacing;
    std::string wordSpacing;
    std::string kerning;
    std::string fontFeatureSettings;
    std::string fontVariantLigatures;
    std::string fontVariationSettings;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                RNSVGClipPathFontStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_fontStyle = map.find("fontStyle");
    if (tmp_fontStyle != map.end()) {
        fromRawValue(context, tmp_fontStyle->second, result.fontStyle);
    }
    auto tmp_fontVariant = map.find("fontVariant");
    if (tmp_fontVariant != map.end()) {
        fromRawValue(context, tmp_fontVariant->second, result.fontVariant);
    }
    auto tmp_fontWeight = map.find("fontWeight");
    if (tmp_fontWeight != map.end()) {
        fromRawValue(context, tmp_fontWeight->second, result.fontWeight);
    }
    auto tmp_fontStretch = map.find("fontStretch");
    if (tmp_fontStretch != map.end()) {
        fromRawValue(context, tmp_fontStretch->second, result.fontStretch);
    }
    auto tmp_fontSize = map.find("fontSize");
    if (tmp_fontSize != map.end()) {
        fromRawValue(context, tmp_fontSize->second, result.fontSize);
    }
    auto tmp_fontFamily = map.find("fontFamily");
    if (tmp_fontFamily != map.end()) {
        fromRawValue(context, tmp_fontFamily->second, result.fontFamily);
    }
    auto tmp_textAnchor = map.find("textAnchor");
    if (tmp_textAnchor != map.end()) {
        fromRawValue(context, tmp_textAnchor->second, result.textAnchor);
    }
    auto tmp_textDecoration = map.find("textDecoration");
    if (tmp_textDecoration != map.end()) {
        fromRawValue(context, tmp_textDecoration->second, result.textDecoration);
    }
    auto tmp_letterSpacing = map.find("letterSpacing");
    if (tmp_letterSpacing != map.end()) {
        fromRawValue(context, tmp_letterSpacing->second, result.letterSpacing);
    }
    auto tmp_wordSpacing = map.find("wordSpacing");
    if (tmp_wordSpacing != map.end()) {
        fromRawValue(context, tmp_wordSpacing->second, result.wordSpacing);
    }
    auto tmp_kerning = map.find("kerning");
    if (tmp_kerning != map.end()) {
        fromRawValue(context, tmp_kerning->second, result.kerning);
    }
    auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
    if (tmp_fontFeatureSettings != map.end()) {
        fromRawValue(context, tmp_fontFeatureSettings->second, result.fontFeatureSettings);
    }
    auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
    if (tmp_fontVariantLigatures != map.end()) {
        fromRawValue(context, tmp_fontVariantLigatures->second, result.fontVariantLigatures);
    }
    auto tmp_fontVariationSettings = map.find("fontVariationSettings");
    if (tmp_fontVariationSettings != map.end()) {
        fromRawValue(context, tmp_fontVariationSettings->second, result.fontVariationSettings);
    }
}

static inline std::string toString(const RNSVGClipPathFontStruct &value) { return "[Object RNSVGClipPathFontStruct]"; }
class JSI_EXPORT RNSVGClipPathProps final : public RNSVGCommonProps {
public:
    RNSVGClipPathProps() = default;
    RNSVGClipPathProps(const PropsParserContext &context, const RNSVGClipPathProps &sourceProps,
                       const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string fontSize{};
    std::string fontWeight{};
    RNSVGClipPathFontStruct font{};
};

class JSI_EXPORT RNSVGDefsProps final : public RNSVGCommonProps {
public:
    RNSVGDefsProps() = default;
    RNSVGDefsProps(const PropsParserContext &context, const RNSVGDefsProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
};


class JSI_EXPORT RNSVGEllipseProps final : public RNSVGCommonProps {
public:
    RNSVGEllipseProps() = default;
    RNSVGEllipseProps(const PropsParserContext &context, const RNSVGEllipseProps &sourceProps,
                      const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string cx{};
    std::string cy{};
    std::string rx{};
    std::string ry{};
};


struct RNSVGForeignObjectFontStruct {
    std::string fontStyle;
    std::string fontVariant;
    std::string fontWeight;
    std::string fontStretch;
    std::string fontSize;
    std::string fontFamily;
    std::string textAnchor;
    std::string textDecoration;
    std::string letterSpacing;
    std::string wordSpacing;
    std::string kerning;
    std::string fontFeatureSettings;
    std::string fontVariantLigatures;
    std::string fontVariationSettings;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                RNSVGForeignObjectFontStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_fontStyle = map.find("fontStyle");
    if (tmp_fontStyle != map.end()) {
        fromRawValue(context, tmp_fontStyle->second, result.fontStyle);
    }
    auto tmp_fontVariant = map.find("fontVariant");
    if (tmp_fontVariant != map.end()) {
        fromRawValue(context, tmp_fontVariant->second, result.fontVariant);
    }
    auto tmp_fontWeight = map.find("fontWeight");
    if (tmp_fontWeight != map.end()) {
        fromRawValue(context, tmp_fontWeight->second, result.fontWeight);
    }
    auto tmp_fontStretch = map.find("fontStretch");
    if (tmp_fontStretch != map.end()) {
        fromRawValue(context, tmp_fontStretch->second, result.fontStretch);
    }
    auto tmp_fontSize = map.find("fontSize");
    if (tmp_fontSize != map.end()) {
        fromRawValue(context, tmp_fontSize->second, result.fontSize);
    }
    auto tmp_fontFamily = map.find("fontFamily");
    if (tmp_fontFamily != map.end()) {
        fromRawValue(context, tmp_fontFamily->second, result.fontFamily);
    }
    auto tmp_textAnchor = map.find("textAnchor");
    if (tmp_textAnchor != map.end()) {
        fromRawValue(context, tmp_textAnchor->second, result.textAnchor);
    }
    auto tmp_textDecoration = map.find("textDecoration");
    if (tmp_textDecoration != map.end()) {
        fromRawValue(context, tmp_textDecoration->second, result.textDecoration);
    }
    auto tmp_letterSpacing = map.find("letterSpacing");
    if (tmp_letterSpacing != map.end()) {
        fromRawValue(context, tmp_letterSpacing->second, result.letterSpacing);
    }
    auto tmp_wordSpacing = map.find("wordSpacing");
    if (tmp_wordSpacing != map.end()) {
        fromRawValue(context, tmp_wordSpacing->second, result.wordSpacing);
    }
    auto tmp_kerning = map.find("kerning");
    if (tmp_kerning != map.end()) {
        fromRawValue(context, tmp_kerning->second, result.kerning);
    }
    auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
    if (tmp_fontFeatureSettings != map.end()) {
        fromRawValue(context, tmp_fontFeatureSettings->second, result.fontFeatureSettings);
    }
    auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
    if (tmp_fontVariantLigatures != map.end()) {
        fromRawValue(context, tmp_fontVariantLigatures->second, result.fontVariantLigatures);
    }
    auto tmp_fontVariationSettings = map.find("fontVariationSettings");
    if (tmp_fontVariationSettings != map.end()) {
        fromRawValue(context, tmp_fontVariationSettings->second, result.fontVariationSettings);
    }
}

static inline std::string toString(const RNSVGForeignObjectFontStruct &value) {
    return "[Object RNSVGForeignObjectFontStruct]";
}
class JSI_EXPORT RNSVGForeignObjectProps final : public RNSVGCommonProps {
public:
    RNSVGForeignObjectProps() = default;
    RNSVGForeignObjectProps(const PropsParserContext &context, const RNSVGForeignObjectProps &sourceProps,
                            const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string fontSize{};
    std::string fontWeight{};
    RNSVGForeignObjectFontStruct font{};
    std::string x{};
    std::string y{};
    std::string height{};
    std::string width{};
};


struct RNSVGGroupFontStruct {
    std::string fontStyle;
    std::string fontVariant;
    std::string fontWeight;
    std::string fontStretch;
    std::string fontSize;
    std::string fontFamily;
    std::string textAnchor;
    std::string textDecoration;
    std::string letterSpacing;
    std::string wordSpacing;
    std::string kerning;
    std::string fontFeatureSettings;
    std::string fontVariantLigatures;
    std::string fontVariationSettings;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                RNSVGGroupFontStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_fontStyle = map.find("fontStyle");
    if (tmp_fontStyle != map.end()) {
        fromRawValue(context, tmp_fontStyle->second, result.fontStyle);
    }
    auto tmp_fontVariant = map.find("fontVariant");
    if (tmp_fontVariant != map.end()) {
        fromRawValue(context, tmp_fontVariant->second, result.fontVariant);
    }
    auto tmp_fontWeight = map.find("fontWeight");
    if (tmp_fontWeight != map.end()) {
        fromRawValue(context, tmp_fontWeight->second, result.fontWeight);
    }
    auto tmp_fontStretch = map.find("fontStretch");
    if (tmp_fontStretch != map.end()) {
        fromRawValue(context, tmp_fontStretch->second, result.fontStretch);
    }
    auto tmp_fontSize = map.find("fontSize");
    if (tmp_fontSize != map.end()) {
        fromRawValue(context, tmp_fontSize->second, result.fontSize);
    }
    auto tmp_fontFamily = map.find("fontFamily");
    if (tmp_fontFamily != map.end()) {
        fromRawValue(context, tmp_fontFamily->second, result.fontFamily);
    }
    auto tmp_textAnchor = map.find("textAnchor");
    if (tmp_textAnchor != map.end()) {
        fromRawValue(context, tmp_textAnchor->second, result.textAnchor);
    }
    auto tmp_textDecoration = map.find("textDecoration");
    if (tmp_textDecoration != map.end()) {
        fromRawValue(context, tmp_textDecoration->second, result.textDecoration);
    }
    auto tmp_letterSpacing = map.find("letterSpacing");
    if (tmp_letterSpacing != map.end()) {
        fromRawValue(context, tmp_letterSpacing->second, result.letterSpacing);
    }
    auto tmp_wordSpacing = map.find("wordSpacing");
    if (tmp_wordSpacing != map.end()) {
        fromRawValue(context, tmp_wordSpacing->second, result.wordSpacing);
    }
    auto tmp_kerning = map.find("kerning");
    if (tmp_kerning != map.end()) {
        fromRawValue(context, tmp_kerning->second, result.kerning);
    }
    auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
    if (tmp_fontFeatureSettings != map.end()) {
        fromRawValue(context, tmp_fontFeatureSettings->second, result.fontFeatureSettings);
    }
    auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
    if (tmp_fontVariantLigatures != map.end()) {
        fromRawValue(context, tmp_fontVariantLigatures->second, result.fontVariantLigatures);
    }
    auto tmp_fontVariationSettings = map.find("fontVariationSettings");
    if (tmp_fontVariationSettings != map.end()) {
        fromRawValue(context, tmp_fontVariationSettings->second, result.fontVariationSettings);
    }
}

static inline std::string toString(const RNSVGGroupFontStruct &value) { return "[Object RNSVGGroupFontStruct]"; }
class JSI_EXPORT RNSVGGroupProps final : public RNSVGCommonProps {
public:
    RNSVGGroupProps() = default;
    RNSVGGroupProps(const PropsParserContext &context, const RNSVGGroupProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string fontSize{};
    std::string fontWeight{};
    RNSVGGroupFontStruct font{};
};


class JSI_EXPORT RNSVGImageProps final : public RNSVGCommonProps {
public:
    RNSVGImageProps() = default;
    RNSVGImageProps(const PropsParserContext &context, const RNSVGImageProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string x{};
    std::string y{};
    std::string width{};
    std::string height{};
    ImageSource src{};
    std::string align{};
    int meetOrSlice{0};
};

class JSI_EXPORT RNSVGSvgViewProps final : public ViewProps {
public:
    RNSVGSvgViewProps() = default;
    RNSVGSvgViewProps(const PropsParserContext &context, const RNSVGSvgViewProps &sourceProps,
                      const RawProps &rawProps);

#pragma mark - Props

    std::string bbWidth{};
    std::string bbHeight{};
    Float minX{0.0};
    Float minY{0.0};
    Float vbWidth{0.0};
    Float vbHeight{0.0};
    std::string align{};
    int meetOrSlice{0};
    SharedColor tintColor{};
    SharedColor color{};
    // std::string pointerEvents{};
};

class JSI_EXPORT RNSVGLinearGradientProps final : public RNSVGCommonProps {
public:
    RNSVGLinearGradientProps() = default;
    RNSVGLinearGradientProps(const PropsParserContext &context, const RNSVGLinearGradientProps &sourceProps,
                             const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string x1{};
    std::string y1{};
    std::string x2{};
    std::string y2{};
    std::vector<Float> gradient{};
    int gradientUnits{0};
    std::vector<Float> gradientTransform{};
};


class JSI_EXPORT RNSVGLineProps final : public RNSVGCommonProps {
public:
    RNSVGLineProps() = default;
    RNSVGLineProps(const PropsParserContext &context, const RNSVGLineProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string x1{};
    std::string y1{};
    std::string x2{};
    std::string y2{};
};


struct RNSVGMarkerFontStruct {
    std::string fontStyle;
    std::string fontVariant;
    std::string fontWeight;
    std::string fontStretch;
    std::string fontSize;
    std::string fontFamily;
    std::string textAnchor;
    std::string textDecoration;
    std::string letterSpacing;
    std::string wordSpacing;
    std::string kerning;
    std::string fontFeatureSettings;
    std::string fontVariantLigatures;
    std::string fontVariationSettings;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                RNSVGMarkerFontStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_fontStyle = map.find("fontStyle");
    if (tmp_fontStyle != map.end()) {
        fromRawValue(context, tmp_fontStyle->second, result.fontStyle);
    }
    auto tmp_fontVariant = map.find("fontVariant");
    if (tmp_fontVariant != map.end()) {
        fromRawValue(context, tmp_fontVariant->second, result.fontVariant);
    }
    auto tmp_fontWeight = map.find("fontWeight");
    if (tmp_fontWeight != map.end()) {
        fromRawValue(context, tmp_fontWeight->second, result.fontWeight);
    }
    auto tmp_fontStretch = map.find("fontStretch");
    if (tmp_fontStretch != map.end()) {
        fromRawValue(context, tmp_fontStretch->second, result.fontStretch);
    }
    auto tmp_fontSize = map.find("fontSize");
    if (tmp_fontSize != map.end()) {
        fromRawValue(context, tmp_fontSize->second, result.fontSize);
    }
    auto tmp_fontFamily = map.find("fontFamily");
    if (tmp_fontFamily != map.end()) {
        fromRawValue(context, tmp_fontFamily->second, result.fontFamily);
    }
    auto tmp_textAnchor = map.find("textAnchor");
    if (tmp_textAnchor != map.end()) {
        fromRawValue(context, tmp_textAnchor->second, result.textAnchor);
    }
    auto tmp_textDecoration = map.find("textDecoration");
    if (tmp_textDecoration != map.end()) {
        fromRawValue(context, tmp_textDecoration->second, result.textDecoration);
    }
    auto tmp_letterSpacing = map.find("letterSpacing");
    if (tmp_letterSpacing != map.end()) {
        fromRawValue(context, tmp_letterSpacing->second, result.letterSpacing);
    }
    auto tmp_wordSpacing = map.find("wordSpacing");
    if (tmp_wordSpacing != map.end()) {
        fromRawValue(context, tmp_wordSpacing->second, result.wordSpacing);
    }
    auto tmp_kerning = map.find("kerning");
    if (tmp_kerning != map.end()) {
        fromRawValue(context, tmp_kerning->second, result.kerning);
    }
    auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
    if (tmp_fontFeatureSettings != map.end()) {
        fromRawValue(context, tmp_fontFeatureSettings->second, result.fontFeatureSettings);
    }
    auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
    if (tmp_fontVariantLigatures != map.end()) {
        fromRawValue(context, tmp_fontVariantLigatures->second, result.fontVariantLigatures);
    }
    auto tmp_fontVariationSettings = map.find("fontVariationSettings");
    if (tmp_fontVariationSettings != map.end()) {
        fromRawValue(context, tmp_fontVariationSettings->second, result.fontVariationSettings);
    }
}

static inline std::string toString(const RNSVGMarkerFontStruct &value) { return "[Object RNSVGMarkerFontStruct]"; }
class JSI_EXPORT RNSVGMarkerProps final : public RNSVGCommonProps {
public:
    RNSVGMarkerProps() = default;
    RNSVGMarkerProps(const PropsParserContext &context, const RNSVGMarkerProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string fontSize{};
    std::string fontWeight{};
    RNSVGMarkerFontStruct font{};
    std::string refX{};
    std::string refY{};
    std::string markerHeight{};
    std::string markerWidth{};
    std::string markerUnits{};
    std::string orient{};
    Float minX{0.0};
    Float minY{0.0};
    Float vbWidth{0.0};
    Float vbHeight{0.0};
    std::string align{};
    int meetOrSlice{0};
};


struct RNSVGMaskFontStruct {
    std::string fontStyle;
    std::string fontVariant;
    std::string fontWeight;
    std::string fontStretch;
    std::string fontSize;
    std::string fontFamily;
    std::string textAnchor;
    std::string textDecoration;
    std::string letterSpacing;
    std::string wordSpacing;
    std::string kerning;
    std::string fontFeatureSettings;
    std::string fontVariantLigatures;
    std::string fontVariationSettings;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value, RNSVGMaskFontStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_fontStyle = map.find("fontStyle");
    if (tmp_fontStyle != map.end()) {
        fromRawValue(context, tmp_fontStyle->second, result.fontStyle);
    }
    auto tmp_fontVariant = map.find("fontVariant");
    if (tmp_fontVariant != map.end()) {
        fromRawValue(context, tmp_fontVariant->second, result.fontVariant);
    }
    auto tmp_fontWeight = map.find("fontWeight");
    if (tmp_fontWeight != map.end()) {
        fromRawValue(context, tmp_fontWeight->second, result.fontWeight);
    }
    auto tmp_fontStretch = map.find("fontStretch");
    if (tmp_fontStretch != map.end()) {
        fromRawValue(context, tmp_fontStretch->second, result.fontStretch);
    }
    auto tmp_fontSize = map.find("fontSize");
    if (tmp_fontSize != map.end()) {
        fromRawValue(context, tmp_fontSize->second, result.fontSize);
    }
    auto tmp_fontFamily = map.find("fontFamily");
    if (tmp_fontFamily != map.end()) {
        fromRawValue(context, tmp_fontFamily->second, result.fontFamily);
    }
    auto tmp_textAnchor = map.find("textAnchor");
    if (tmp_textAnchor != map.end()) {
        fromRawValue(context, tmp_textAnchor->second, result.textAnchor);
    }
    auto tmp_textDecoration = map.find("textDecoration");
    if (tmp_textDecoration != map.end()) {
        fromRawValue(context, tmp_textDecoration->second, result.textDecoration);
    }
    auto tmp_letterSpacing = map.find("letterSpacing");
    if (tmp_letterSpacing != map.end()) {
        fromRawValue(context, tmp_letterSpacing->second, result.letterSpacing);
    }
    auto tmp_wordSpacing = map.find("wordSpacing");
    if (tmp_wordSpacing != map.end()) {
        fromRawValue(context, tmp_wordSpacing->second, result.wordSpacing);
    }
    auto tmp_kerning = map.find("kerning");
    if (tmp_kerning != map.end()) {
        fromRawValue(context, tmp_kerning->second, result.kerning);
    }
    auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
    if (tmp_fontFeatureSettings != map.end()) {
        fromRawValue(context, tmp_fontFeatureSettings->second, result.fontFeatureSettings);
    }
    auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
    if (tmp_fontVariantLigatures != map.end()) {
        fromRawValue(context, tmp_fontVariantLigatures->second, result.fontVariantLigatures);
    }
    auto tmp_fontVariationSettings = map.find("fontVariationSettings");
    if (tmp_fontVariationSettings != map.end()) {
        fromRawValue(context, tmp_fontVariationSettings->second, result.fontVariationSettings);
    }
}

static inline std::string toString(const RNSVGMaskFontStruct &value) { return "[Object RNSVGMaskFontStruct]"; }
class JSI_EXPORT RNSVGMaskProps final : public RNSVGCommonProps {
public:
    RNSVGMaskProps() = default;
    RNSVGMaskProps(const PropsParserContext &context, const RNSVGMaskProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string fontSize{};
    std::string fontWeight{};
    RNSVGMaskFontStruct font{};
    std::string x{};
    std::string y{};
    std::string height{};
    std::string width{};
    int maskUnits{0};
    int maskContentUnits{0};
};


class JSI_EXPORT RNSVGPathProps final : public RNSVGCommonProps {
public:
    RNSVGPathProps() = default;
    RNSVGPathProps(const PropsParserContext &context, const RNSVGPathProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string d{};
};


struct RNSVGPatternFontStruct {
    std::string fontStyle;
    std::string fontVariant;
    std::string fontWeight;
    std::string fontStretch;
    std::string fontSize;
    std::string fontFamily;
    std::string textAnchor;
    std::string textDecoration;
    std::string letterSpacing;
    std::string wordSpacing;
    std::string kerning;
    std::string fontFeatureSettings;
    std::string fontVariantLigatures;
    std::string fontVariationSettings;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                RNSVGPatternFontStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_fontStyle = map.find("fontStyle");
    if (tmp_fontStyle != map.end()) {
        fromRawValue(context, tmp_fontStyle->second, result.fontStyle);
    }
    auto tmp_fontVariant = map.find("fontVariant");
    if (tmp_fontVariant != map.end()) {
        fromRawValue(context, tmp_fontVariant->second, result.fontVariant);
    }
    auto tmp_fontWeight = map.find("fontWeight");
    if (tmp_fontWeight != map.end()) {
        fromRawValue(context, tmp_fontWeight->second, result.fontWeight);
    }
    auto tmp_fontStretch = map.find("fontStretch");
    if (tmp_fontStretch != map.end()) {
        fromRawValue(context, tmp_fontStretch->second, result.fontStretch);
    }
    auto tmp_fontSize = map.find("fontSize");
    if (tmp_fontSize != map.end()) {
        fromRawValue(context, tmp_fontSize->second, result.fontSize);
    }
    auto tmp_fontFamily = map.find("fontFamily");
    if (tmp_fontFamily != map.end()) {
        fromRawValue(context, tmp_fontFamily->second, result.fontFamily);
    }
    auto tmp_textAnchor = map.find("textAnchor");
    if (tmp_textAnchor != map.end()) {
        fromRawValue(context, tmp_textAnchor->second, result.textAnchor);
    }
    auto tmp_textDecoration = map.find("textDecoration");
    if (tmp_textDecoration != map.end()) {
        fromRawValue(context, tmp_textDecoration->second, result.textDecoration);
    }
    auto tmp_letterSpacing = map.find("letterSpacing");
    if (tmp_letterSpacing != map.end()) {
        fromRawValue(context, tmp_letterSpacing->second, result.letterSpacing);
    }
    auto tmp_wordSpacing = map.find("wordSpacing");
    if (tmp_wordSpacing != map.end()) {
        fromRawValue(context, tmp_wordSpacing->second, result.wordSpacing);
    }
    auto tmp_kerning = map.find("kerning");
    if (tmp_kerning != map.end()) {
        fromRawValue(context, tmp_kerning->second, result.kerning);
    }
    auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
    if (tmp_fontFeatureSettings != map.end()) {
        fromRawValue(context, tmp_fontFeatureSettings->second, result.fontFeatureSettings);
    }
    auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
    if (tmp_fontVariantLigatures != map.end()) {
        fromRawValue(context, tmp_fontVariantLigatures->second, result.fontVariantLigatures);
    }
    auto tmp_fontVariationSettings = map.find("fontVariationSettings");
    if (tmp_fontVariationSettings != map.end()) {
        fromRawValue(context, tmp_fontVariationSettings->second, result.fontVariationSettings);
    }
}

static inline std::string toString(const RNSVGPatternFontStruct &value) { return "[Object RNSVGPatternFontStruct]"; }
class JSI_EXPORT RNSVGPatternProps final : public RNSVGCommonProps {
public:
    RNSVGPatternProps() = default;
    RNSVGPatternProps(const PropsParserContext &context, const RNSVGPatternProps &sourceProps,
                      const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string fontSize{};
    std::string fontWeight{};
    RNSVGPatternFontStruct font{};
    std::string x{};
    std::string y{};
    std::string height{};
    std::string width{};
    int patternUnits{0};
    int patternContentUnits{0};
    std::vector<Float> patternTransform{};
    Float minX{0.0};
    Float minY{0.0};
    Float vbWidth{0.0};
    Float vbHeight{0.0};
    std::string align{};
    int meetOrSlice{0};
};

class JSI_EXPORT RNSVGRadialGradientProps final : public RNSVGCommonProps {
public:
    RNSVGRadialGradientProps() = default;
    RNSVGRadialGradientProps(const PropsParserContext &context, const RNSVGRadialGradientProps &sourceProps,
                             const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string fx{};
    std::string fy{};
    std::string cx{};
    std::string cy{};
    std::string rx{};
    std::string ry{};
    std::vector<Float> gradient{};
    int gradientUnits{0};
    std::vector<Float> gradientTransform{};
};


class JSI_EXPORT RNSVGRectProps final : public RNSVGCommonProps {
public:
    RNSVGRectProps() = default;
    RNSVGRectProps(const PropsParserContext &context, const RNSVGRectProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string x{};
    std::string y{};
    std::string height{};
    std::string width{};
    std::string rx{};
    std::string ry{};
};


struct RNSVGSymbolFontStruct {
    std::string fontStyle;
    std::string fontVariant;
    std::string fontWeight;
    std::string fontStretch;
    std::string fontSize;
    std::string fontFamily;
    std::string textAnchor;
    std::string textDecoration;
    std::string letterSpacing;
    std::string wordSpacing;
    std::string kerning;
    std::string fontFeatureSettings;
    std::string fontVariantLigatures;
    std::string fontVariationSettings;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                RNSVGSymbolFontStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_fontStyle = map.find("fontStyle");
    if (tmp_fontStyle != map.end()) {
        fromRawValue(context, tmp_fontStyle->second, result.fontStyle);
    }
    auto tmp_fontVariant = map.find("fontVariant");
    if (tmp_fontVariant != map.end()) {
        fromRawValue(context, tmp_fontVariant->second, result.fontVariant);
    }
    auto tmp_fontWeight = map.find("fontWeight");
    if (tmp_fontWeight != map.end()) {
        fromRawValue(context, tmp_fontWeight->second, result.fontWeight);
    }
    auto tmp_fontStretch = map.find("fontStretch");
    if (tmp_fontStretch != map.end()) {
        fromRawValue(context, tmp_fontStretch->second, result.fontStretch);
    }
    auto tmp_fontSize = map.find("fontSize");
    if (tmp_fontSize != map.end()) {
        fromRawValue(context, tmp_fontSize->second, result.fontSize);
    }
    auto tmp_fontFamily = map.find("fontFamily");
    if (tmp_fontFamily != map.end()) {
        fromRawValue(context, tmp_fontFamily->second, result.fontFamily);
    }
    auto tmp_textAnchor = map.find("textAnchor");
    if (tmp_textAnchor != map.end()) {
        fromRawValue(context, tmp_textAnchor->second, result.textAnchor);
    }
    auto tmp_textDecoration = map.find("textDecoration");
    if (tmp_textDecoration != map.end()) {
        fromRawValue(context, tmp_textDecoration->second, result.textDecoration);
    }
    auto tmp_letterSpacing = map.find("letterSpacing");
    if (tmp_letterSpacing != map.end()) {
        fromRawValue(context, tmp_letterSpacing->second, result.letterSpacing);
    }
    auto tmp_wordSpacing = map.find("wordSpacing");
    if (tmp_wordSpacing != map.end()) {
        fromRawValue(context, tmp_wordSpacing->second, result.wordSpacing);
    }
    auto tmp_kerning = map.find("kerning");
    if (tmp_kerning != map.end()) {
        fromRawValue(context, tmp_kerning->second, result.kerning);
    }
    auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
    if (tmp_fontFeatureSettings != map.end()) {
        fromRawValue(context, tmp_fontFeatureSettings->second, result.fontFeatureSettings);
    }
    auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
    if (tmp_fontVariantLigatures != map.end()) {
        fromRawValue(context, tmp_fontVariantLigatures->second, result.fontVariantLigatures);
    }
    auto tmp_fontVariationSettings = map.find("fontVariationSettings");
    if (tmp_fontVariationSettings != map.end()) {
        fromRawValue(context, tmp_fontVariationSettings->second, result.fontVariationSettings);
    }
}

static inline std::string toString(const RNSVGSymbolFontStruct &value) { return "[Object RNSVGSymbolFontStruct]"; }
class JSI_EXPORT RNSVGSymbolProps final : public RNSVGCommonProps {
public:
    RNSVGSymbolProps() = default;
    RNSVGSymbolProps(const PropsParserContext &context, const RNSVGSymbolProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string fontSize{};
    std::string fontWeight{};
    RNSVGSymbolFontStruct font{};
    Float minX{0.0};
    Float minY{0.0};
    Float vbWidth{0.0};
    Float vbHeight{0.0};
    std::string align{};
    int meetOrSlice{0};
};


struct RNSVGTextFontStruct {
    std::string fontStyle;
    std::string fontVariant;
    std::string fontWeight;
    std::string fontStretch;
    std::string fontSize;
    std::string fontFamily;
    std::string textAnchor;
    std::string textDecoration;
    std::string letterSpacing;
    std::string wordSpacing;
    std::string kerning;
    std::string fontFeatureSettings;
    std::string fontVariantLigatures;
    std::string fontVariationSettings;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value, RNSVGTextFontStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_fontStyle = map.find("fontStyle");
    if (tmp_fontStyle != map.end()) {
        fromRawValue(context, tmp_fontStyle->second, result.fontStyle);
    }
    auto tmp_fontVariant = map.find("fontVariant");
    if (tmp_fontVariant != map.end()) {
        fromRawValue(context, tmp_fontVariant->second, result.fontVariant);
    }
    auto tmp_fontWeight = map.find("fontWeight");
    if (tmp_fontWeight != map.end()) {
        fromRawValue(context, tmp_fontWeight->second, result.fontWeight);
    }
    auto tmp_fontStretch = map.find("fontStretch");
    if (tmp_fontStretch != map.end()) {
        fromRawValue(context, tmp_fontStretch->second, result.fontStretch);
    }
    auto tmp_fontSize = map.find("fontSize");
    if (tmp_fontSize != map.end()) {
        fromRawValue(context, tmp_fontSize->second, result.fontSize);
    }
    auto tmp_fontFamily = map.find("fontFamily");
    if (tmp_fontFamily != map.end()) {
        fromRawValue(context, tmp_fontFamily->second, result.fontFamily);
    }
    auto tmp_textAnchor = map.find("textAnchor");
    if (tmp_textAnchor != map.end()) {
        fromRawValue(context, tmp_textAnchor->second, result.textAnchor);
    }
    auto tmp_textDecoration = map.find("textDecoration");
    if (tmp_textDecoration != map.end()) {
        fromRawValue(context, tmp_textDecoration->second, result.textDecoration);
    }
    auto tmp_letterSpacing = map.find("letterSpacing");
    if (tmp_letterSpacing != map.end()) {
        fromRawValue(context, tmp_letterSpacing->second, result.letterSpacing);
    }
    auto tmp_wordSpacing = map.find("wordSpacing");
    if (tmp_wordSpacing != map.end()) {
        fromRawValue(context, tmp_wordSpacing->second, result.wordSpacing);
    }
    auto tmp_kerning = map.find("kerning");
    if (tmp_kerning != map.end()) {
        fromRawValue(context, tmp_kerning->second, result.kerning);
    }
    auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
    if (tmp_fontFeatureSettings != map.end()) {
        fromRawValue(context, tmp_fontFeatureSettings->second, result.fontFeatureSettings);
    }
    auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
    if (tmp_fontVariantLigatures != map.end()) {
        fromRawValue(context, tmp_fontVariantLigatures->second, result.fontVariantLigatures);
    }
    auto tmp_fontVariationSettings = map.find("fontVariationSettings");
    if (tmp_fontVariationSettings != map.end()) {
        fromRawValue(context, tmp_fontVariationSettings->second, result.fontVariationSettings);
    }
}

static inline std::string toString(const RNSVGTextFontStruct &value) {
    return "fontSTyle = " + value.fontStyle + " fontVariant = " + value.fontVariant +
           " fontWeight = " + value.fontWeight + " fontStretch = " + value.fontStretch +
           " fontSize = " + value.fontSize + " fontFamily = " + value.fontFamily + " textAnchor = " + value.textAnchor +
           " textDecoration = " + value.textDecoration + " letterSpacing = " + value.letterSpacing +
           " wordSpacing = " + value.wordSpacing + " kerning = " + value.kerning +
           " fontFeatureSettings = " + value.fontFeatureSettings +
           " fontVariantLigatures = " + value.fontVariantLigatures +
           " fontVariationSettings = " + value.fontVariationSettings;
}
class JSI_EXPORT RNSVGTextProps final : public RNSVGCommonProps {
public:
    RNSVGTextProps() = default;
    RNSVGTextProps(const PropsParserContext &context, const RNSVGTextProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string fontSize{};
    std::string fontWeight{};
    RNSVGTextFontStruct font{};
    std::vector<std::string> dx{};
    std::vector<std::string> dy{};
    std::vector<std::string> x{};
    std::vector<std::string> y{};
    std::vector<std::string> rotate{};
    std::string inlineSize{};
    std::string textLength{};
    std::string baselineShift{};
    std::string lengthAdjust{};
    std::string alignmentBaseline{};
    std::string verticalAlign{};
};


struct RNSVGTextPathFontStruct {
    std::string fontStyle;
    std::string fontVariant;
    std::string fontWeight;
    std::string fontStretch;
    std::string fontSize;
    std::string fontFamily;
    std::string textAnchor;
    std::string textDecoration;
    std::string letterSpacing;
    std::string wordSpacing;
    std::string kerning;
    std::string fontFeatureSettings;
    std::string fontVariantLigatures;
    std::string fontVariationSettings;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                RNSVGTextPathFontStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_fontStyle = map.find("fontStyle");
    if (tmp_fontStyle != map.end()) {
        fromRawValue(context, tmp_fontStyle->second, result.fontStyle);
    }
    auto tmp_fontVariant = map.find("fontVariant");
    if (tmp_fontVariant != map.end()) {
        fromRawValue(context, tmp_fontVariant->second, result.fontVariant);
    }
    auto tmp_fontWeight = map.find("fontWeight");
    if (tmp_fontWeight != map.end()) {
        fromRawValue(context, tmp_fontWeight->second, result.fontWeight);
    }
    auto tmp_fontStretch = map.find("fontStretch");
    if (tmp_fontStretch != map.end()) {
        fromRawValue(context, tmp_fontStretch->second, result.fontStretch);
    }
    auto tmp_fontSize = map.find("fontSize");
    if (tmp_fontSize != map.end()) {
        fromRawValue(context, tmp_fontSize->second, result.fontSize);
    }
    auto tmp_fontFamily = map.find("fontFamily");
    if (tmp_fontFamily != map.end()) {
        fromRawValue(context, tmp_fontFamily->second, result.fontFamily);
    }
    auto tmp_textAnchor = map.find("textAnchor");
    if (tmp_textAnchor != map.end()) {
        fromRawValue(context, tmp_textAnchor->second, result.textAnchor);
    }
    auto tmp_textDecoration = map.find("textDecoration");
    if (tmp_textDecoration != map.end()) {
        fromRawValue(context, tmp_textDecoration->second, result.textDecoration);
    }
    auto tmp_letterSpacing = map.find("letterSpacing");
    if (tmp_letterSpacing != map.end()) {
        fromRawValue(context, tmp_letterSpacing->second, result.letterSpacing);
    }
    auto tmp_wordSpacing = map.find("wordSpacing");
    if (tmp_wordSpacing != map.end()) {
        fromRawValue(context, tmp_wordSpacing->second, result.wordSpacing);
    }
    auto tmp_kerning = map.find("kerning");
    if (tmp_kerning != map.end()) {
        fromRawValue(context, tmp_kerning->second, result.kerning);
    }
    auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
    if (tmp_fontFeatureSettings != map.end()) {
        fromRawValue(context, tmp_fontFeatureSettings->second, result.fontFeatureSettings);
    }
    auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
    if (tmp_fontVariantLigatures != map.end()) {
        fromRawValue(context, tmp_fontVariantLigatures->second, result.fontVariantLigatures);
    }
    auto tmp_fontVariationSettings = map.find("fontVariationSettings");
    if (tmp_fontVariationSettings != map.end()) {
        fromRawValue(context, tmp_fontVariationSettings->second, result.fontVariationSettings);
    }
}

static inline std::string toString(const RNSVGTextPathFontStruct &value) { return "[Object RNSVGTextPathFontStruct]"; }
class JSI_EXPORT RNSVGTextPathProps final : public RNSVGCommonProps {
public:
    RNSVGTextPathProps() = default;
    RNSVGTextPathProps(const PropsParserContext &context, const RNSVGTextPathProps &sourceProps,
                       const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string fontSize{};
    std::string fontWeight{};
    RNSVGTextPathFontStruct font{};
    std::vector<std::string> dx{};
    std::vector<std::string> dy{};
    std::vector<std::string> x{};
    std::vector<std::string> y{};
    std::vector<std::string> rotate{};
    std::string inlineSize{};
    std::string textLength{};
    std::string baselineShift{};
    std::string lengthAdjust{};
    std::string alignmentBaseline{};
    std::string verticalAlign{};
    std::string href{};
    std::string side{};
    std::string method{};
    std::string midLine{};
    std::string spacing{};
    std::string startOffset{};
};


struct RNSVGTSpanFontStruct {
    std::string fontStyle;
    std::string fontVariant;
    std::string fontWeight;
    std::string fontStretch;
    std::string fontSize;
    std::string fontFamily;
    std::string textAnchor;
    std::string textDecoration;
    std::string letterSpacing;
    std::string wordSpacing;
    std::string kerning;
    std::string fontFeatureSettings;
    std::string fontVariantLigatures;
    std::string fontVariationSettings;
};

static inline void fromRawValue(const PropsParserContext &context, const RawValue &value,
                                RNSVGTSpanFontStruct &result) {
    auto map = (butter::map<std::string, RawValue>)value;

    auto tmp_fontStyle = map.find("fontStyle");
    if (tmp_fontStyle != map.end()) {
        fromRawValue(context, tmp_fontStyle->second, result.fontStyle);
    }
    auto tmp_fontVariant = map.find("fontVariant");
    if (tmp_fontVariant != map.end()) {
        fromRawValue(context, tmp_fontVariant->second, result.fontVariant);
    }
    auto tmp_fontWeight = map.find("fontWeight");
    if (tmp_fontWeight != map.end()) {
        fromRawValue(context, tmp_fontWeight->second, result.fontWeight);
    }
    auto tmp_fontStretch = map.find("fontStretch");
    if (tmp_fontStretch != map.end()) {
        fromRawValue(context, tmp_fontStretch->second, result.fontStretch);
    }
    auto tmp_fontSize = map.find("fontSize");
    if (tmp_fontSize != map.end()) {
        fromRawValue(context, tmp_fontSize->second, result.fontSize);
    }
    auto tmp_fontFamily = map.find("fontFamily");
    if (tmp_fontFamily != map.end()) {
        fromRawValue(context, tmp_fontFamily->second, result.fontFamily);
    }
    auto tmp_textAnchor = map.find("textAnchor");
    if (tmp_textAnchor != map.end()) {
        fromRawValue(context, tmp_textAnchor->second, result.textAnchor);
    }
    auto tmp_textDecoration = map.find("textDecoration");
    if (tmp_textDecoration != map.end()) {
        fromRawValue(context, tmp_textDecoration->second, result.textDecoration);
    }
    auto tmp_letterSpacing = map.find("letterSpacing");
    if (tmp_letterSpacing != map.end()) {
        fromRawValue(context, tmp_letterSpacing->second, result.letterSpacing);
    }
    auto tmp_wordSpacing = map.find("wordSpacing");
    if (tmp_wordSpacing != map.end()) {
        fromRawValue(context, tmp_wordSpacing->second, result.wordSpacing);
    }
    auto tmp_kerning = map.find("kerning");
    if (tmp_kerning != map.end()) {
        fromRawValue(context, tmp_kerning->second, result.kerning);
    }
    auto tmp_fontFeatureSettings = map.find("fontFeatureSettings");
    if (tmp_fontFeatureSettings != map.end()) {
        fromRawValue(context, tmp_fontFeatureSettings->second, result.fontFeatureSettings);
    }
    auto tmp_fontVariantLigatures = map.find("fontVariantLigatures");
    if (tmp_fontVariantLigatures != map.end()) {
        fromRawValue(context, tmp_fontVariantLigatures->second, result.fontVariantLigatures);
    }
    auto tmp_fontVariationSettings = map.find("fontVariationSettings");
    if (tmp_fontVariationSettings != map.end()) {
        fromRawValue(context, tmp_fontVariationSettings->second, result.fontVariationSettings);
    }
}

static inline std::string toString(const RNSVGTSpanFontStruct &value) { return "[Object RNSVGTSpanFontStruct]"; }
class JSI_EXPORT RNSVGTSpanProps final : public RNSVGCommonProps {
public:
    RNSVGTSpanProps() = default;
    RNSVGTSpanProps(const PropsParserContext &context, const RNSVGTSpanProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string fontSize{};
    std::string fontWeight{};
    RNSVGTSpanFontStruct font{};
    std::vector<std::string> dx{};
    std::vector<std::string> dy{};
    std::vector<std::string> x{};
    std::vector<std::string> y{};
    std::vector<std::string> rotate{};
    std::string inlineSize{};
    std::string textLength{};
    std::string baselineShift{};
    std::string lengthAdjust{};
    std::string alignmentBaseline{};
    std::string verticalAlign{};
    std::string content{};
};


class JSI_EXPORT RNSVGUseProps final : public RNSVGCommonProps {
public:
    RNSVGUseProps() = default;
    RNSVGUseProps(const PropsParserContext &context, const RNSVGUseProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props



    // std::string pointerEvents{};
    std::string href{};
    std::string x{};
    std::string y{};
    std::string height{};
    std::string width{};
};

} // namespace react
} // namespace facebook
